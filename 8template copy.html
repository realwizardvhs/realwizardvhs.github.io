<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.2.0/p5.min.js"></script>
    <meta charset="UTF-8">
    <title>Grid-based Particle Movement</title>
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-12 text-center">
                <div id="sketch-holder"></div>
            </div>
        </div>
    </div>

    <script>
        let canvas;
        let particles = [];
        let cols, rows;
        const cellSize = 60;  // Size of each grid cell
        const maxCharsPerLine = 3;  // Max characters per line for wrapping
        const gridWidth = 10; // Number of columns in the grid
        const gridHeight = 10; // Number of rows in the grid

        class AsciiParticle {
            constructor(x, y, chars) {
                this.gridX = x;
                this.gridY = y;
                this.x = this.gridX * cellSize + cellSize / 2;
                this.y = this.gridY * cellSize + cellSize / 2;
                this.vx = random(-1, 1);  // Horizontal velocity
                this.vy = random(-1, 1);  // Vertical velocity
                this.chars = this.wrapText(chars); // Handle character wrapping
            }

            // Wrap text based on the maxCharsPerLine
            wrapText(text) {
                let wrappedText = '';
                for (let i = 0; i < text.length; i++) {
                    wrappedText += text[i];
                    if ((i + 1) % maxCharsPerLine === 0 && i !== text.length - 1) {
                        wrappedText += '\n';  // Insert newline after maxCharsPerLine characters
                    }
                }
                return wrappedText;
            }

            // Update particle's position and make sure it adheres to the grid
            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Make sure particles "snap" to the grid
                this.gridX = floor(this.x / cellSize);
                this.gridY = floor(this.y / cellSize);

                // Boundaries wrapping (particles reappear on the opposite side)
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }

            display() {
                // Snap to grid center based on current grid position
                let gridCenterX = this.gridX * cellSize + cellSize / 2;
                let gridCenterY = this.gridY * cellSize + cellSize / 2;

                // Display the wrapped text at the grid position
                text(this.chars, gridCenterX, gridCenterY);
            }
        }

        function setup() {
            canvas = createCanvas(600, 600);
            canvas.parent("sketch-holder");
            textSize(14);
            textAlign(CENTER, CENTER);
            cols = floor(width / cellSize);
            rows = floor(height / cellSize);

            let chars = ['#', '@', '%', '&', '*', '$', '!'];

            // Create particles and place them in grid cells
            for (let row = 0; row < gridHeight; row++) {
                for (let col = 0; col < gridWidth; col++) {
                    let randomChars = chars[floor(random(chars.length))];
                    let particleChars = '';
                    
                    // Create random number of characters per particle (1-3 characters per line, up to 9 total)
                    for (let i = 0; i < floor(random(1, 10)); i++) {
                        particleChars += randomChars;
                    }
                    particles.push(new AsciiParticle(col, row, particleChars));
                }
            }
        }

        function draw() {
            background(255);

            // Update and display each particle
            for (let p of particles) {
                p.update();
                p.display();
            }
        }
    </script>
</body>
</html>
